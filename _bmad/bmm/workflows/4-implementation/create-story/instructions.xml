<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and generate all documents in {document_output_language}</critical>

  <!-- CONTEXT BOUNDARIES (per BMAD standards) -->
  <context-boundaries>
    <available>Sprint status, epics file, PRD, architecture, UX docs, previous stories, git history, project context</available>
    <focus>Creating comprehensive, implementation-ready story files with exhaustive developer guidance</focus>
    <limits>Do not implement the story; do not modify source documents; do not skip artifact analysis</limits>
    <dependencies>Epics file must exist; sprint-status recommended; Linear integration optional</dependencies>
  </context-boundaries>

  <!-- EXECUTION PROTOCOLS: Each <action> tag serves as an execution protocol directive -->

  <critical>üî• CRITICAL MISSION: You are creating the ULTIMATE story context engine that prevents LLM developer mistakes, omissions or
    disasters! üî•</critical>
  <critical>Your purpose is NOT to copy from epics - it's to create a comprehensive, optimized story file that gives the DEV agent
    EVERYTHING needed for flawless implementation</critical>
  <critical>COMMON LLM MISTAKES TO PREVENT: reinventing wheels, wrong libraries, wrong file locations, breaking regressions, ignoring UX,
    vague implementations, lying about completion, not learning from past work</critical>
  <critical>üö® EXHAUSTIVE ANALYSIS REQUIRED: You must thoroughly analyze ALL artifacts to extract critical context - do NOT be lazy or skim!
    This is the most important function in the entire development process!</critical>
  <critical>üî¨ UTILIZE SUBPROCESSES AND SUBAGENTS: Use research subagents, subprocesses or parallel processing if available to thoroughly
    analyze different artifacts simultaneously and thoroughly</critical>
  <critical>‚ùì SAVE QUESTIONS: If you think of questions or clarifications during analysis, save them for the end after the complete story is
    written</critical>
  <critical>üéØ ZERO USER INTERVENTION: Process should be fully automated except for initial epic/story selection or missing documents</critical>

  <step n="1" goal="Determine target story">
    <!-- ADW SDK Integration: Check for ADW environment first -->
    <check if="environment variable ADW_STATE_FILE is set and file exists">
      <critical>Running in ADW environment - detect via ADW_STATE_FILE existence</critical>

      <!-- Verify ADW_STATE_FILE exists -->
      <action>Check ADW environment:
        if [ -n "$ADW_STATE_FILE" ] && [ -f "$ADW_STATE_FILE" ]; then
          echo "ADW environment detected"
        fi
      </action>

      <!-- Parse story ID from ADW_ISSUE_BODY if available -->
      <check if="environment variable ADW_ISSUE_BODY is set and non-empty">
        <action>Parse story ID from ADW_ISSUE_BODY (expected format: "1.2" or "1-2")</action>
        <action>Extract epic_num (first number) and story_num (second number)</action>
        <action>Set {{epic_num}} and {{story_num}} from parsed values</action>
      </check>

      <!-- Fallback: Check if story_id already exists in state file -->
      <check if="ADW_ISSUE_BODY not set but story_id exists in ADW_STATE_FILE">
        <action>Read story_id from state: jq -r '.story_id // empty' "$ADW_STATE_FILE"</action>
        <action>Parse {{epic_num}} and {{story_num}} from story_id</action>
      </check>

      <action>Derive {{story_key}} by looking up the story in epics file or sprint-status matching epic_num-story_num pattern</action>
      <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>

      <!-- Update ADW state file with story_id for subsequent commands -->
      <action>Read current state from $ADW_STATE_FILE</action>
      <action>Add "story_id": "{{story_id}}" to the state JSON</action>
      <action>Write updated state back to $ADW_STATE_FILE using:
        jq '. + {"story_id": "{{story_id}}"}' $ADW_STATE_FILE > tmp.json && mv tmp.json $ADW_STATE_FILE
      </action>
      <output>ü§ñ ADW Mode: Story {{story_id}} detected from ADW environment</output>
      <action>GOTO step 2</action>
    </check>

    <!-- Normal flow: user-provided or auto-discover -->
    <check if="{{story_path}} is provided by user or user provided the epic and story number such as 2-4 or 1.6 or epic 1 story 5">
      <action>Parse user-provided story path: extract epic_num, story_num, story_title from format like "1-2-user-auth"</action>
      <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
      <action>GOTO step 2</action>
    </check>

    <action>Check if {{sprint_status}} file exists for auto discover</action>
    <check if="sprint status file does NOT exist">
      <output>üö´ No sprint status file found and no story specified</output>
      <output>
        **Required Options:**
        1. Run `sprint-planning` to initialize sprint tracking (recommended)
        2. Provide specific epic-story number to draft (e.g., "1-2-user-auth")
        3. Provide path to story documents if sprint status doesn't exist yet
      </output>
      <ask>Choose option [1], provide epic-story number, path to story docs, or [q] to quit:</ask>

      <check if="user chooses 'q'">
        <action>HALT - No work needed</action>
      </check>

      <check if="user chooses '1'">
        <output>Run sprint-planning workflow first to create sprint-status.yaml</output>
        <action>HALT - User needs to run sprint-planning</action>
      </check>

      <check if="user provides epic-story number">
        <action>Parse user input: extract epic_num, story_num, story_title</action>
        <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
        <action>GOTO step 2</action>
      </check>

      <check if="user provides story docs path">
        <action>Use user-provided path for story documents</action>
        <action>GOTO step 2</action>
      </check>
    </check>

    <!-- Auto-discover from sprint status only if no user input -->
    <check if="no user input provided">
      <critical>MUST read COMPLETE {sprint_status} file from start to end to preserve order</critical>
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Read ALL lines from beginning to end - do not skip any content</action>
      <action>Parse the development_status section completely</action>

      <action>Find the FIRST story (by reading in order from top to bottom) where:
        - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
        - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
        - Status value equals "backlog"
      </action>

      <check if="no backlog story found">
        <output>üìã No backlog stories found in sprint-status.yaml

          All stories are either already drafted, in progress, or done.

          **Options:**
          1. Run sprint-planning to refresh story tracking
          2. Load PM agent and run correct-course to add more stories
          3. Check if current sprint is complete and run retrospective
        </output>
        <action>HALT</action>
      </check>

      <action>Extract from found story key (e.g., "1-2-user-authentication"):
        - epic_num: first number before dash (e.g., "1")
        - story_num: second number after first dash (e.g., "2")
        - story_title: remainder after second dash (e.g., "user-authentication")
      </action>
      <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
      <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>

      <!-- Mark epic as in-progress if this is first story -->
      <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
      <check if="this is first story in epic {{epic_num}}">
        <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
        <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
        <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
        <action>If epic status is "in-progress" ‚Üí no change needed</action>
        <check if="epic status is 'done'">
          <output>üö´ ERROR: Cannot create story in completed epic</output>
          <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
          <output>If you need to add more work, either:</output>
          <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
          <output>2. Create a new epic for additional work</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <check if="epic status is not one of: backlog, contexted, in-progress, done">
          <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
          <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
          <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <output>üìä Epic {{epic_num}} status updated to in-progress</output>
      </check>

      <action>GOTO step 2</action>
    </check>
  </step>

  <step n="2" goal="Load relevant conditional documentation">
    <critical>Check for relevant feature docs BEFORE loading other context - prevents reinventing wheels!</critical>

    <action>Check if {project-root}/docs/CONDITIONAL_DOCS.md exists</action>

    <check if="CONDITIONAL_DOCS.md exists">
      <action>Read and parse the conditional docs guide</action>
      <action>Extract story context keywords from:
        - Story key/title (e.g., "3-2-implement-auth-middleware" ‚Üí "auth", "middleware", "implement")
        - Epic name and description from epics file
        - Any story description available
      </action>

      <action>For each entry in CONDITIONAL_DOCS.md Documentation Map:
        - Parse the conditions list for that doc
        - Check if any condition keywords match story context keywords
        - Collect paths of all matching docs
      </action>

      <check if="matching docs found">
        <action>Load content of each matching feature doc</action>
        <action>Store combined content as {{conditional_docs_content}}</action>
        <output>üìö **Relevant Feature Documentation Loaded:**
          {{#matched_docs}}
          - {{doc_path}} (matched: "{{matched_condition}}")
          {{/matched_docs}}

          This existing knowledge will be included in the story context.
        </output>
      </check>

      <check if="no matching docs">
        <action>Set {{conditional_docs_content}} = empty</action>
        <output>‚ÑπÔ∏è No matching conditional docs found for this story context.</output>
      </check>
    </check>

    <check if="CONDITIONAL_DOCS.md does NOT exist">
      <action>Set {{conditional_docs_content}} = empty</action>
      <note>No conditional docs guide configured - skipping feature doc lookup</note>
    </check>

    <action>GOTO step 3</action>
  </step>

  <step n="3" goal="Load and analyze core artifacts">
    <!-- Role Reinforcement: You are a meticulous artifact analyst extracting every relevant detail -->
    <critical>üî¨ EXHAUSTIVE ARTIFACT ANALYSIS - This is where you prevent future developer fuckups!</critical>

    <!-- Load all available content through discovery protocol -->
    <invoke-protocol
      name="discover_inputs" />
    <note>Available content: {epics_content}, {prd_content}, {architecture_content}, {ux_content},
    {project_context}</note>

    <!-- Analyze epics file for story foundation -->
    <action>From {epics_content}, extract Epic {{epic_num}} complete context:</action> **EPIC ANALYSIS:** - Epic
    objectives and business value - ALL stories in this epic for cross-story context - Our specific story's requirements, user story
    statement, acceptance criteria - Technical requirements and constraints - Dependencies on other stories/epics - Source hints pointing to
    original documents <!-- Extract specific story requirements -->
    <action>Extract our story ({{epic_num}}-{{story_num}}) details:</action> **STORY FOUNDATION:** - User story statement
    (As a, I want, so that) - Detailed acceptance criteria (already BDD formatted) - Technical requirements specific to this story -
    Business context and value - Success criteria <!-- Previous story analysis for context continuity -->
    <check if="story_num > 1">
      <action>Load previous story file: {{story_dir}}/{{epic_num}}-{{previous_story_num}}-*.md</action> **PREVIOUS STORY INTELLIGENCE:** -
    Dev notes and learnings from previous story - Review feedback and corrections needed - Files that were created/modified and their
    patterns - Testing approaches that worked/didn't work - Problems encountered and solutions found - Code patterns established <action>Extract
    all learnings that could impact current story implementation</action>
    </check>

    <!-- Git intelligence for previous work patterns -->
    <check
      if="previous story exists AND git repository detected">
      <action>Get last 5 commit titles to understand recent work patterns</action>
      <action>Analyze 1-5 most recent commits for relevance to current story:
        - Files created/modified
        - Code patterns and conventions used
        - Library dependencies added/changed
        - Architecture decisions implemented
        - Testing approaches used
      </action>
      <action>Extract actionable insights for current story implementation</action>
    </check>
  </step>

  <step n="4" goal="Architecture analysis for developer guardrails">
    <!-- Role Reinforcement: You are a technical architect ensuring developer compliance with system design -->
    <critical>üèóÔ∏è ARCHITECTURE INTELLIGENCE - Extract everything the developer MUST follow!</critical> **ARCHITECTURE DOCUMENT ANALYSIS:** <action>Systematically
    analyze architecture content for story-relevant requirements:</action>

    <!-- Load architecture - single file or sharded -->
    <check if="architecture file is single file">
      <action>Load complete {architecture_content}</action>
    </check>
    <check if="architecture is sharded to folder">
      <action>Load architecture index and scan all architecture files</action>
    </check> **CRITICAL ARCHITECTURE EXTRACTION:** <action>For
    each architecture section, determine if relevant to this story:</action> - **Technical Stack:** Languages, frameworks, libraries with
    versions - **Code Structure:** Folder organization, naming conventions, file patterns - **API Patterns:** Service structure, endpoint
    patterns, data contracts - **Database Schemas:** Tables, relationships, constraints relevant to story - **Security Requirements:**
    Authentication patterns, authorization rules - **Performance Requirements:** Caching strategies, optimization patterns - **Testing
    Standards:** Testing frameworks, coverage expectations, test patterns - **Deployment Patterns:** Environment configurations, build
    processes - **Integration Patterns:** External service integrations, data flows <action>Extract any story-specific requirements that the
    developer MUST follow</action>
    <action>Identify any architectural decisions that override previous patterns</action>
  </step>

  <step n="5" goal="Web research for latest technical specifics">
    <critical>üåê ENSURE LATEST TECH KNOWLEDGE - Prevent outdated implementations!</critical> **WEB INTELLIGENCE:** <action>Identify specific
    technical areas that require latest version knowledge:</action>

    <!-- Check for libraries/frameworks mentioned in architecture -->
    <action>From architecture analysis, identify specific libraries, APIs, or
    frameworks</action>
    <action>For each critical technology, research latest stable version and key changes:
      - Latest API documentation and breaking changes
      - Security vulnerabilities or updates
      - Performance improvements or deprecations
      - Best practices for current version
    </action>
    **EXTERNAL CONTEXT INCLUSION:** <action>Include in story any critical latest information the developer needs:
      - Specific library versions and why chosen
      - API endpoints with parameters and authentication
      - Recent security patches or considerations
      - Performance optimization techniques
      - Migration considerations if upgrading
    </action>
  </step>

  <step n="6" goal="Create comprehensive story file">
    <!-- Role Reinforcement: You are a technical writer creating the definitive developer implementation guide -->
    <critical>üìù CREATE ULTIMATE STORY FILE - The developer's master implementation guide!</critical>

    <action>Initialize from template.md:
    {default_output_file}</action>
    <template-output file="{default_output_file}">story_header</template-output>

    <!-- Story foundation from epics analysis -->
    <template-output
      file="{default_output_file}">story_requirements</template-output>

    <!-- Conditional docs content - existing feature knowledge -->
    <check if="{{conditional_docs_content}} is not empty">
      <template-output file="{default_output_file}">conditional_docs_section</template-output>
      <action>Include {{conditional_docs_content}} in the story under "## Relevant Feature Documentation" section</action>
      <note>This gives the dev agent access to existing patterns and knowledge that matched this story's context</note>
    </check>

    <!-- Developer context section - MOST IMPORTANT PART -->
    <template-output file="{default_output_file}">
    developer_context_section</template-output> **DEV AGENT GUARDRAILS:** <template-output file="{default_output_file}">
    technical_requirements</template-output>
    <template-output file="{default_output_file}">architecture_compliance</template-output>
    <template-output
      file="{default_output_file}">library_framework_requirements</template-output>
    <template-output file="{default_output_file}">
    file_structure_requirements</template-output>
    <template-output file="{default_output_file}">testing_requirements</template-output>

    <!-- Previous story intelligence -->
    <check
      if="previous story learnings available">
      <template-output file="{default_output_file}">previous_story_intelligence</template-output>
    </check>

    <!-- Git intelligence -->
    <check
      if="git analysis completed">
      <template-output file="{default_output_file}">git_intelligence_summary</template-output>
    </check>

    <!-- Latest technical specifics -->
    <check if="web research completed">
      <template-output file="{default_output_file}">latest_tech_information</template-output>
    </check>

    <!-- Project context reference -->
    <template-output
      file="{default_output_file}">project_context_reference</template-output>

    <!-- Final status update -->
    <template-output file="{default_output_file}">
    story_completion_status</template-output>

    <!-- CRITICAL: Set status to ready-for-dev -->
    <action>Set story Status to: "ready-for-dev"</action>
    <action>Add completion note: "Ultimate
    context engine analysis completed - comprehensive developer guide created"</action>
  </step>

  <step n="7" goal="Update sprint status, Linear integration, and finalize">
    <invoke-task>Validate against checklist at {installed_path}/checklist.md using _bmad/core/tasks/validate-workflow.xml</invoke-task>
    <action>Save story document unconditionally</action>

    <!-- ADW SDK Integration: Update plan_file in state for subsequent phases -->
    <check if="environment variable ADW_STATE_FILE is set and file exists">
      <action>Update ADW state with plan_file pointing to the created story:
        jq '. + {"plan_file": "{{story_file}}"}' $ADW_STATE_FILE > tmp.json && mv tmp.json $ADW_STATE_FILE
      </action>
      <output>ü§ñ ADW: Updated plan_file in state ‚Üí {{story_file}}</output>
    </check>

    <!-- Linear Issue Integration -->
    <critical>Ensure story is linked to Linear issue tracking</critical>
    <action>Check if project has .linear configuration file at {project-root}/.linear</action>

    <check if=".linear config exists">
      <action>Extract story title from {{story_key}} (e.g., "1-2-user-auth" ‚Üí "User Auth")</action>

      <!-- PRIORITY: Check for existing Linear issue from ADW state first -->
      <check if="ADW_STATE_FILE exists AND contains linear_issue_id">
        <action>Extract existing issue ID from ADW state:
          jq -r '.linear_issue_id // empty' "$ADW_STATE_FILE"</action>
        <action>Store result as {{existing_linear_issue_id}}</action>

        <check if="{{existing_linear_issue_id}} is not empty">
          <action>Set {{linear_issue_id}} = {{existing_linear_issue_id}}</action>
          <output>üîó ADW: Using existing Linear issue {{linear_issue_id}}</output>

          <!-- Update story file with the existing Linear issue ID -->
          <action>Update the story file's "Linear Issue:" field with {{linear_issue_id}}</action>
          <action>Save story file</action>

          <!-- Update existing Linear issue with full story content -->
          <action>Pipe the complete story file content to update the Linear issue description:
            cat "{{story_file}}" | python {linear_scripts_path}/update_issue.py {{linear_issue_id}} --description-stdin</action>

          <!-- Verify the description was updated successfully -->
          <action>Verify issue was updated by checking response success</action>
          <check if="update command failed or returned error">
            <output>‚ö†Ô∏è Warning: Linear issue description update may have failed. Manual update may be required.</output>
            <output>Story file: {{story_file}}</output>
            <output>Linear issue: {{linear_issue_id}}</output>
          </check>

          <!-- Move issue to Todo state -->
          <action>Get team workflow states: python {linear_scripts_path}/get_teams.py --detailed --json</action>
          <action>Find the state ID for "Todo" or "Backlog" status</action>
          <action>Update issue to Todo state: python {linear_scripts_path}/update_issue.py {{linear_issue_id}} --state-id {{todo_state_id}}</action>

          <output>üîó **Linear Issue Updated:** {{linear_issue_id}}
            Status: Todo
            Description: Updated with full story content via stdin
            Link: https://linear.app/issue/{{linear_issue_id}}
          </output>

          <!-- Skip to sprint status update - don't create new issue -->
          <action>GOTO sprint status update section</action>
        </check>
      </check>

      <!-- Fallback: Create new issue if no existing issue found -->
      <check if="{{linear_issue_id}} is not set">
        <!-- Create issue with placeholder description first -->
        <action>Create Linear issue with title: "[{{story_id}}] {{story_title_formatted}}"</action>
        <action>Run: python {linear_scripts_path}/create_issue.py \
          --title "[{{story_id}}] {{story_title_formatted}}" \
          --description "Story: {{story_key}} - Full content loading..." \
          --json</action>
        <action>Parse the returned JSON to extract the issue identifier (e.g., "ENG-123")</action>
        <action>Store as {{linear_issue_id}}</action>

        <!-- Update story file with Linear issue ID before updating Linear with full content -->
        <action>Update the story file's "Linear Issue:" field with {{linear_issue_id}}</action>
        <action>Save story file</action>

        <!-- Update Linear issue with full story content via stdin piping -->
        <action>Pipe the complete story file content to update the Linear issue description:
          cat "{{story_file}}" | python {linear_scripts_path}/update_issue.py {{linear_issue_id}} --description-stdin</action>

        <!-- Verify the description was updated successfully -->
        <action>Verify issue was updated by checking response success</action>
        <check if="update command failed or returned error">
          <output>‚ö†Ô∏è Warning: Linear issue description update may have failed. Manual update may be required.</output>
          <output>Story file: {{story_file}}</output>
          <output>Linear issue: {{linear_issue_id}}</output>
        </check>

        <!-- Move issue to Todo state -->
        <action>Get team workflow states: python {linear_scripts_path}/get_teams.py --detailed --json</action>
        <action>Find the state ID for "Todo" or "Backlog" status</action>
        <action>Update issue to Todo state: python {linear_scripts_path}/update_issue.py {{linear_issue_id}} --state-id {{todo_state_id}}</action>

        <output>üîó **Linear Issue Created:** {{linear_issue_id}}
          Status: Todo
          Description: Updated with full story content via stdin
          Link: https://linear.app/issue/{{linear_issue_id}}
        </output>
      </check>
    </check>

    <check if=".linear config does NOT exist">
      <output>‚ÑπÔ∏è No .linear configuration found - skipping Linear integration
        To enable: Create .linear file in project root with workspace config
      </output>
      <action>Set {{linear_issue_id}} = "not-configured"</action>
    </check>

    <!-- Update sprint status -->
    <check if="sprint status file exists">
      <action>Update {{sprint_status}}</action>
      <action>Load the FULL file and read all development_status entries</action>
      <action>Find development_status key matching {{story_key}}</action>
      <action>Verify current status is "backlog" (expected previous state)</action>
      <action>Update development_status[{{story_key}}] = "ready-for-dev"</action>
      <action>Save file, preserving ALL comments and structure including STATUS DEFINITIONS</action>
    </check>

    <action>Report completion</action>
    <output>**üéØ ULTIMATE BMad Method STORY CONTEXT CREATED, {user_name}!**

      **Story Details:**
      - Story ID: {{story_id}}
      - Story Key: {{story_key}}
      - File: {{story_file}}
      - Status: ready-for-dev

      **Next Steps:**
      1. Review the comprehensive story in {{story_file}}
      2. **Optional Quality Competition:** Run the scrum masters `*validate-create-story` to have a fresh LLM systematically review and
      improve the story context
      3. Run dev agents `dev-story` for optimized implementation
      4. Run `code-review` when complete (auto-marks done)

      **Quality Competition Option:** The `*validate-create-story` command runs the story context through an independent LLM in fresh
      context that will:
      - Systematically re-analyze all source documents
      - Identify any misses, omissions, or improvements
      - Compete to create a more comprehensive story context
      - Present findings interactively for your approval
      - Apply improvements to create the ultimate developer implementation guide

      **The developer now has everything needed for flawless implementation!**
    </output>
  </step>

  <!-- SUCCESS/FAILURE METRICS (per BMAD standards) -->
  <metrics>
    <success>
      <item>Story file created at {story_dir}/{{story_key}}.md with all required sections</item>
      <item>Exhaustive artifact analysis completed (epics, architecture, previous stories, git history)</item>
      <item>Developer guardrails extracted and documented</item>
      <item>Sprint status updated from "backlog" to "ready-for-dev"</item>
      <item>Linear issue created OR updated with full story content (if .linear config exists)</item>
      <item>ADW state updated with story_id and plan_file (if ADW environment)</item>
      <item>Validation checklist passed via validate-workflow.xml</item>
    </success>
    <failure>
      <item>No epic/story found in source files or sprint status</item>
      <item>Incomplete or superficial artifact analysis (skimming instead of exhaustive review)</item>
      <item>Missing critical developer context (architecture constraints, previous learnings)</item>
      <item>Story file created without required sections or with placeholder content</item>
      <item>Sprint status not updated after story creation</item>
      <item>Linear integration failed without graceful fallback messaging</item>
      <item>Proceeding without user input when story selection is ambiguous</item>
    </failure>
  </metrics>

  <master-rule>Skipping artifact analysis, optimizing sequences, or creating superficial story context is FORBIDDEN and constitutes SYSTEM FAILURE.</master-rule>

</workflow>